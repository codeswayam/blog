<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>_index on Swayam Blog</title>
    <link>/posts/dsa/</link>
    <description>Recent content in _index on Swayam Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 01 Feb 2025 00:00:00 +0000</lastBuildDate><atom:link href="/posts/dsa/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Basic Overview of DSA</title>
      <link>/posts/dsa/basic-overview-of-dsa/</link>
      <pubDate>Sun, 05 Jan 2025 00:00:00 +0000</pubDate>
      
      <guid>/posts/dsa/basic-overview-of-dsa/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Arrays&lt;/strong&gt;: Linear data structure with a fixed size, allowing random access to elements.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Best for: Static datasets with frequent element access.&lt;/li&gt;
&lt;li&gt;Complexity:
&lt;ul&gt;
&lt;li&gt;Access: O(1)&lt;/li&gt;
&lt;li&gt;Search: O(n)&lt;/li&gt;
&lt;li&gt;Insertion/Deletion: O(n)
&lt;a href=&#34;/posts/dsa/array/&#34;&gt;Array&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Linked Lists&lt;/strong&gt;: Linear structure of nodes, where each node points to the next.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Types: Singly, Doubly, Circular.&lt;/li&gt;
&lt;li&gt;Best for: Dynamic datasets with frequent insertions/deletions.&lt;/li&gt;
&lt;li&gt;Complexity:
&lt;ul&gt;
&lt;li&gt;Access/Search: O(n)&lt;/li&gt;
&lt;li&gt;Insertion/Deletion: O(1) (at head/tail with pointer)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hash Maps (or Hash Tables)&lt;/strong&gt;: Key-value pair storage with a hash function.&lt;/p&gt;</description>
      <content>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Arrays&lt;/strong&gt;: Linear data structure with a fixed size, allowing random access to elements.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Best for: Static datasets with frequent element access.&lt;/li&gt;
&lt;li&gt;Complexity:
&lt;ul&gt;
&lt;li&gt;Access: O(1)&lt;/li&gt;
&lt;li&gt;Search: O(n)&lt;/li&gt;
&lt;li&gt;Insertion/Deletion: O(n)
&lt;a href=&#34;/posts/dsa/array/&#34;&gt;Array&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Linked Lists&lt;/strong&gt;: Linear structure of nodes, where each node points to the next.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Types: Singly, Doubly, Circular.&lt;/li&gt;
&lt;li&gt;Best for: Dynamic datasets with frequent insertions/deletions.&lt;/li&gt;
&lt;li&gt;Complexity:
&lt;ul&gt;
&lt;li&gt;Access/Search: O(n)&lt;/li&gt;
&lt;li&gt;Insertion/Deletion: O(1) (at head/tail with pointer)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hash Maps (or Hash Tables)&lt;/strong&gt;: Key-value pair storage with a hash function.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Best for: Quick lookup and insertion.&lt;/li&gt;
&lt;li&gt;Complexity:
&lt;ul&gt;
&lt;li&gt;Average: O(1)&lt;/li&gt;
&lt;li&gt;Worst-case: O(n)(due to hash collisions)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Stacks&lt;/strong&gt;: LIFO (Last In, First Out) structure.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Operations: Push, Pop, Peek.&lt;/li&gt;
&lt;li&gt;Best for: Recursive problems, expression evaluation.&lt;/li&gt;
&lt;li&gt;Complexity:
&lt;ul&gt;
&lt;li&gt;Push/Pop/Peek: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Queues&lt;/strong&gt;: FIFO (First In, First Out) structure.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variants: Circular Queue, Deque, Priority Queue.&lt;/li&gt;
&lt;li&gt;Best for: Scheduling, buffering.&lt;/li&gt;
&lt;li&gt;Complexity:
&lt;ul&gt;
&lt;li&gt;Enqueue/Dequeue: O(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Trees&lt;/strong&gt;: Hierarchical structure with nodes (root, parent, children).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Types: Binary, Binary Search Tree (BST), AVL, Red-Black, etc.&lt;/li&gt;
&lt;li&gt;Best for: Hierarchical data, searching/sorting.&lt;/li&gt;
&lt;li&gt;Complexity:
&lt;ul&gt;
&lt;li&gt;Search/Insert/Delete: O(h), where h is the tree height.&lt;/li&gt;
&lt;li&gt;Balanced trees maintain h=O(logn).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Graphs&lt;/strong&gt;: Collection of nodes (vertices) connected by edges.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Types: Directed, Undirected, Weighted, Unweighted.&lt;/li&gt;
&lt;li&gt;Representation: Adjacency Matrix/List.&lt;/li&gt;
&lt;li&gt;Best for: Network problems, pathfinding.&lt;/li&gt;
&lt;li&gt;Algorithms: DFS, BFS, Dijkstra’s, Prim’s, Kruskal’s.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>Array</title>
      <link>/posts/dsa/array/</link>
      <pubDate>Sat, 01 Feb 2025 00:00:00 +0000</pubDate>
      
      <guid>/posts/dsa/array/</guid>
      <description>&lt;h2 id=&#34;sort&#34;&gt;Sort&lt;/h2&gt;
&lt;h3 id=&#34;1-comparison-based-sorting&#34;&gt;&lt;strong&gt;1. Comparison-Based Sorting&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;These algorithms compare elements to determine their order.&lt;/p&gt;
&lt;h4 id=&#34;a-bubble-sort&#34;&gt;&lt;strong&gt;a. Bubble Sort&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Repeatedly swaps adjacent elements if they are in the wrong order.&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(n²)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(1)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;b-selection-sort&#34;&gt;&lt;strong&gt;b. Selection Sort&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Finds the smallest element and places it in the correct position.&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(n²)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(1)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;c-insertion-sort&#34;&gt;&lt;strong&gt;c. Insertion Sort&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Picks one element at a time and places it in its correct position.&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(n²)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(1)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Efficient for small or nearly sorted data.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;d-merge-sort-divide-and-conquer&#34;&gt;&lt;strong&gt;d. Merge Sort&lt;/strong&gt; (Divide and Conquer)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Divides the array into halves, sorts them, and merges them.&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(n log n)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(n)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;e-quick-sort-divide-and-conquer&#34;&gt;&lt;strong&gt;e. Quick Sort&lt;/strong&gt; (Divide and Conquer)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Picks a pivot, partitions the array, and sorts recursively.&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(n log n)&lt;/strong&gt; (Best &amp;amp; Avg), &lt;strong&gt;O(n²)&lt;/strong&gt; (Worst)&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(log n)&lt;/strong&gt; (due to recursion)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;f-heap-sort&#34;&gt;&lt;strong&gt;f. Heap Sort&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Converts the array into a heap and extracts elements in order.&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(n log n)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(1)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;g-shell-sort&#34;&gt;&lt;strong&gt;g. Shell Sort&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Variation of insertion sort that sorts elements at a gap.&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(n log n)&lt;/strong&gt; (Best), &lt;strong&gt;O(n²)&lt;/strong&gt; (Worst)&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(1)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-non-comparison-based-sorting&#34;&gt;&lt;strong&gt;2. Non-Comparison-Based Sorting&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;These algorithms do not compare elements directly.&lt;/p&gt;</description>
      <content>&lt;h2 id=&#34;sort&#34;&gt;Sort&lt;/h2&gt;
&lt;h3 id=&#34;1-comparison-based-sorting&#34;&gt;&lt;strong&gt;1. Comparison-Based Sorting&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;These algorithms compare elements to determine their order.&lt;/p&gt;
&lt;h4 id=&#34;a-bubble-sort&#34;&gt;&lt;strong&gt;a. Bubble Sort&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Repeatedly swaps adjacent elements if they are in the wrong order.&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(n²)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(1)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;b-selection-sort&#34;&gt;&lt;strong&gt;b. Selection Sort&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Finds the smallest element and places it in the correct position.&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(n²)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(1)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;c-insertion-sort&#34;&gt;&lt;strong&gt;c. Insertion Sort&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Picks one element at a time and places it in its correct position.&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(n²)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(1)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Efficient for small or nearly sorted data.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;d-merge-sort-divide-and-conquer&#34;&gt;&lt;strong&gt;d. Merge Sort&lt;/strong&gt; (Divide and Conquer)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Divides the array into halves, sorts them, and merges them.&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(n log n)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(n)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;e-quick-sort-divide-and-conquer&#34;&gt;&lt;strong&gt;e. Quick Sort&lt;/strong&gt; (Divide and Conquer)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Picks a pivot, partitions the array, and sorts recursively.&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(n log n)&lt;/strong&gt; (Best &amp;amp; Avg), &lt;strong&gt;O(n²)&lt;/strong&gt; (Worst)&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(log n)&lt;/strong&gt; (due to recursion)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;f-heap-sort&#34;&gt;&lt;strong&gt;f. Heap Sort&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Converts the array into a heap and extracts elements in order.&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(n log n)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(1)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;g-shell-sort&#34;&gt;&lt;strong&gt;g. Shell Sort&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Variation of insertion sort that sorts elements at a gap.&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(n log n)&lt;/strong&gt; (Best), &lt;strong&gt;O(n²)&lt;/strong&gt; (Worst)&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(1)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-non-comparison-based-sorting&#34;&gt;&lt;strong&gt;2. Non-Comparison-Based Sorting&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;These algorithms do not compare elements directly.&lt;/p&gt;
&lt;h4 id=&#34;a-counting-sort&#34;&gt;&lt;strong&gt;a. Counting Sort&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Counts occurrences of elements and places them in sorted order.&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(n + k)&lt;/strong&gt; (k is range of numbers)&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(k)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Works only for integer values with a known range.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;b-radix-sort&#34;&gt;&lt;strong&gt;b. Radix Sort&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Sorts numbers digit by digit using counting sort as a subroutine.&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(nk)&lt;/strong&gt; (k is number of digits)&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(n + k)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Works well for fixed-size numbers like integers.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;c-bucket-sort&#34;&gt;&lt;strong&gt;c. Bucket Sort&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Divides elements into buckets and sorts each bucket individually.&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(n + k)&lt;/strong&gt; (depends on bucket distribution)&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(n + k)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Works well for uniformly distributed data.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-hybrid-sorting-algorithms&#34;&gt;&lt;strong&gt;3. Hybrid Sorting Algorithms&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;These algorithms combine multiple sorting techniques.&lt;/p&gt;
&lt;h4 id=&#34;a-tim-sort&#34;&gt;&lt;strong&gt;a. Tim Sort&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Combination of Merge Sort and Insertion Sort.&lt;/li&gt;
&lt;li&gt;Used in Python’s built-in sorting (&lt;code&gt;sorted()&lt;/code&gt; and &lt;code&gt;.sort()&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(n log n)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(n)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;b-introsort&#34;&gt;&lt;strong&gt;b. Introsort&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Hybrid of Quick Sort, Heap Sort, and Insertion Sort.&lt;/li&gt;
&lt;li&gt;Used in C++ STL &lt;code&gt;sort()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Time Complexity: &lt;strong&gt;O(n log n)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Space Complexity: &lt;strong&gt;O(log n)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;choosing-the-right-sorting-algorithm&#34;&gt;&lt;strong&gt;Choosing the Right Sorting Algorithm&lt;/strong&gt;&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;Algorithm&lt;/th&gt;
          &lt;th&gt;Best Case&lt;/th&gt;
          &lt;th&gt;Worst Case&lt;/th&gt;
          &lt;th&gt;Average Case&lt;/th&gt;
          &lt;th&gt;Space Complexity&lt;/th&gt;
          &lt;th&gt;Stable?&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Bubble Sort&lt;/td&gt;
          &lt;td&gt;O(n)&lt;/td&gt;
          &lt;td&gt;O(n²)&lt;/td&gt;
          &lt;td&gt;O(n²)&lt;/td&gt;
          &lt;td&gt;O(1)&lt;/td&gt;
          &lt;td&gt;Yes&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Selection Sort&lt;/td&gt;
          &lt;td&gt;O(n²)&lt;/td&gt;
          &lt;td&gt;O(n²)&lt;/td&gt;
          &lt;td&gt;O(n²)&lt;/td&gt;
          &lt;td&gt;O(1)&lt;/td&gt;
          &lt;td&gt;No&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Insertion Sort&lt;/td&gt;
          &lt;td&gt;O(n)&lt;/td&gt;
          &lt;td&gt;O(n²)&lt;/td&gt;
          &lt;td&gt;O(n²)&lt;/td&gt;
          &lt;td&gt;O(1)&lt;/td&gt;
          &lt;td&gt;Yes&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Merge Sort&lt;/td&gt;
          &lt;td&gt;O(n log n)&lt;/td&gt;
          &lt;td&gt;O(n log n)&lt;/td&gt;
          &lt;td&gt;O(n log n)&lt;/td&gt;
          &lt;td&gt;O(n)&lt;/td&gt;
          &lt;td&gt;Yes&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Quick Sort&lt;/td&gt;
          &lt;td&gt;O(n log n)&lt;/td&gt;
          &lt;td&gt;O(n²)&lt;/td&gt;
          &lt;td&gt;O(n log n)&lt;/td&gt;
          &lt;td&gt;O(log n)&lt;/td&gt;
          &lt;td&gt;No&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Heap Sort&lt;/td&gt;
          &lt;td&gt;O(n log n)&lt;/td&gt;
          &lt;td&gt;O(n log n)&lt;/td&gt;
          &lt;td&gt;O(n log n)&lt;/td&gt;
          &lt;td&gt;O(1)&lt;/td&gt;
          &lt;td&gt;No&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Counting Sort&lt;/td&gt;
          &lt;td&gt;O(n + k)&lt;/td&gt;
          &lt;td&gt;O(n + k)&lt;/td&gt;
          &lt;td&gt;O(n + k)&lt;/td&gt;
          &lt;td&gt;O(k)&lt;/td&gt;
          &lt;td&gt;Yes&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Radix Sort&lt;/td&gt;
          &lt;td&gt;O(nk)&lt;/td&gt;
          &lt;td&gt;O(nk)&lt;/td&gt;
          &lt;td&gt;O(nk)&lt;/td&gt;
          &lt;td&gt;O(n + k)&lt;/td&gt;
          &lt;td&gt;Yes&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Bucket Sort&lt;/td&gt;
          &lt;td&gt;O(n + k)&lt;/td&gt;
          &lt;td&gt;O(n²)&lt;/td&gt;
          &lt;td&gt;O(n)&lt;/td&gt;
          &lt;td&gt;O(n + k)&lt;/td&gt;
          &lt;td&gt;Yes&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Tim Sort&lt;/td&gt;
          &lt;td&gt;O(n)&lt;/td&gt;
          &lt;td&gt;O(n log n)&lt;/td&gt;
          &lt;td&gt;O(n log n)&lt;/td&gt;
          &lt;td&gt;O(n)&lt;/td&gt;
          &lt;td&gt;Yes&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</content>
    </item>
    
  </channel>
</rss>
